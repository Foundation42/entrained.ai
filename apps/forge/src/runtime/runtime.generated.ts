// AUTO-GENERATED - Do not edit directly!
// Source: src/runtime/runtime.js
// Run: bun run build:runtime

export const RUNTIME_JS = "// Forge Runtime - Client-side WebComponent Library\n\nclass StorageAPI {\n  constructor(baseUrl, componentId, scope, instanceId) {\n    this.baseUrl = baseUrl;\n    this.componentId = componentId;\n    this.scope = scope;\n    this.instanceId = instanceId;\n    this._pending = new Map();\n    this._timers = new Map();\n  }\n\n  url(key) {\n    const base = this.baseUrl + '/api/forge/' + this.componentId;\n    if (this.scope === 'instance') {\n      return key ? base + '/instance/' + this.instanceId + '/data/' + key : base + '/instance/' + this.instanceId + '/data';\n    } else if (this.scope === 'class') {\n      return key ? base + '/class/data/' + key : base + '/class/data';\n    } else {\n      return key ? this.baseUrl + '/api/forge/global/data/' + key : this.baseUrl + '/api/forge/global/data';\n    }\n  }\n\n  async get(key) {\n    // Return pending write for read-your-writes consistency\n    if (this._pending.has(key)) return this._pending.get(key);\n    try {\n      const response = await fetch(this.url(key));\n      if (!response.ok) return null;\n      const data = await response.json();\n      return data.value;\n    } catch { return null; }\n  }\n\n  async set(key, value) {\n    // Store pending value for read-your-writes\n    this._pending.set(key, value);\n    // Debounce writes (300ms) to avoid KV rate limiting\n    if (this._timers.has(key)) clearTimeout(this._timers.get(key));\n    this._timers.set(key, setTimeout(async () => {\n      this._timers.delete(key);\n      try {\n        await fetch(this.url(key), {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(value),\n        });\n      } finally {\n        if (this._pending.get(key) === value) this._pending.delete(key);\n      }\n    }, 300));\n  }\n\n  async delete(key) {\n    this._pending.delete(key);\n    await fetch(this.url(key), { method: 'DELETE' });\n  }\n\n  async list() {\n    try {\n      const response = await fetch(this.url());\n      if (!response.ok) return [];\n      const data = await response.json();\n      return data.keys || [];\n    } catch { return []; }\n  }\n}\n\n// Current component being rendered (for event delegation)\nlet _currentComponent = null;\n\n// Events to delegate (covers most common use cases)\nconst _delegatedEvents = ['click', 'dblclick', 'input', 'change', 'submit', 'keydown', 'keyup', 'keypress', 'focus', 'blur', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'touchstart', 'touchend'];\n\n// DOM morphing - updates existing DOM to match new structure while preserving focus\nfunction morph(fromNode, toNode) {\n  // Different node types - replace entirely (use actual node, not clone, to preserve handlers)\n  if (fromNode.nodeType !== toNode.nodeType || fromNode.nodeName !== toNode.nodeName) {\n    fromNode.parentNode?.replaceChild(toNode, fromNode);\n    return;\n  }\n\n  // Text nodes - update content\n  if (fromNode.nodeType === 3) {\n    if (fromNode.textContent !== toNode.textContent) {\n      fromNode.textContent = toNode.textContent;\n    }\n    return;\n  }\n\n  // Element nodes\n  if (fromNode.nodeType === 1) {\n    // Skip morphing focused inputs to preserve cursor position\n    // Use :focus pseudo-class which works correctly in Shadow DOM\n    const isFocused = fromNode.matches && fromNode.matches(':focus');\n    const isFocusedInput = isFocused &&\n      (fromNode.tagName === 'INPUT' || fromNode.tagName === 'TEXTAREA' || fromNode.tagName === 'SELECT');\n\n    // Update attributes (but preserve value on focused inputs)\n    const fromAttrs = new Set(Array.from(fromNode.attributes).map(a => a.name));\n    const toAttrs = new Set(Array.from(toNode.attributes).map(a => a.name));\n\n    // Remove old attributes\n    for (const name of fromAttrs) {\n      if (!toAttrs.has(name)) fromNode.removeAttribute(name);\n    }\n\n    // Add/update attributes\n    for (const attr of toNode.attributes) {\n      // Skip value on focused inputs\n      if (isFocusedInput && attr.name === 'value') continue;\n      if (fromNode.getAttribute(attr.name) !== attr.value) {\n        fromNode.setAttribute(attr.name, attr.value);\n      }\n    }\n\n    // Sync special properties (but not on focused inputs)\n    if (!isFocusedInput) {\n      if ('value' in toNode && fromNode.value !== toNode.value) fromNode.value = toNode.value;\n      if ('checked' in toNode && fromNode.checked !== toNode.checked) fromNode.checked = toNode.checked;\n      if ('selected' in toNode && fromNode.selected !== toNode.selected) fromNode.selected = toNode.selected;\n    }\n\n    // Event handlers are now delegated at shadow root level via data-forge-* attributes\n    // No need to transfer handlers during morph - they're looked up dynamically\n\n    // Morph children\n    const fromChildren = Array.from(fromNode.childNodes);\n    const toChildren = Array.from(toNode.childNodes);\n\n    // Build key map for efficient matching\n    const fromKeyMap = new Map();\n    fromChildren.forEach((child, i) => {\n      const key = child.nodeType === 1 ? child.getAttribute('key') || child.getAttribute('id') : null;\n      if (key) fromKeyMap.set(key, { node: child, index: i });\n    });\n\n    let fromIndex = 0;\n    for (let toIndex = 0; toIndex < toChildren.length; toIndex++) {\n      const toChild = toChildren[toIndex];\n      const toKey = toChild.nodeType === 1 ? toChild.getAttribute('key') || toChild.getAttribute('id') : null;\n\n      // Try to find matching node by key\n      if (toKey && fromKeyMap.has(toKey)) {\n        const match = fromKeyMap.get(toKey);\n        if (match.index !== fromIndex) {\n          // Move node to correct position\n          fromNode.insertBefore(match.node, fromChildren[fromIndex] || null);\n        }\n        morph(match.node, toChild);\n        fromIndex++;\n        continue;\n      }\n\n      // Match by position\n      if (fromIndex < fromChildren.length) {\n        const fromChild = fromChildren[fromIndex];\n        // If types match, morph; otherwise replace (use actual node to preserve handlers)\n        if (fromChild.nodeType === toChild.nodeType && fromChild.nodeName === toChild.nodeName) {\n          morph(fromChild, toChild);\n        } else {\n          fromNode.replaceChild(toChild, fromChild);\n        }\n        fromIndex++;\n      } else {\n        // No more from children - append (use actual node to preserve handlers)\n        fromNode.appendChild(toChild);\n      }\n    }\n\n    // Remove extra from children\n    while (fromIndex < fromChildren.length) {\n      fromNode.removeChild(fromChildren[fromIndex]);\n      fromIndex++;\n    }\n  }\n}\n\nexport function Component(options) {\n  return function(target) {\n    // Store metadata directly on class (more robust than WeakMap with decorators)\n    target.__forgeMetadata__ = options;\n    if (!customElements.get(options.tag)) {\n      customElements.define(options.tag, target);\n    }\n    return target;\n  };\n}\n\nexport class ForgeComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._instanceId = crypto.randomUUID();\n    this._baseUrl = this.getAttribute('data-forge-url') || 'https://forge.entrained.ai';\n    this._componentId = this.getAttribute('data-forge-id') || this.tagName.toLowerCase();\n    this._props = {};\n\n    // Event delegation: handlers registered per-render, looked up by ID at event time\n    this._handlers = new Map();\n    this._handlerCounter = 0;\n    this._hasRendered = false;\n\n    this.instance = new StorageAPI(this._baseUrl, this._componentId, 'instance', this._instanceId);\n    this.class = new StorageAPI(this._baseUrl, this._componentId, 'class');\n    this.global = new StorageAPI(this._baseUrl, this._componentId, 'global');\n  }\n\n  get props() { return this._props; }\n\n  initProps() {\n    const metadata = this.constructor.__forgeMetadata__;\n    if (!metadata?.props) return;\n    for (const [name, config] of Object.entries(metadata.props)) {\n      const attrValue = this.getAttribute(name);\n      if (attrValue !== null) {\n        if (config.type === Number) this._props[name] = parseFloat(attrValue);\n        else if (config.type === Boolean) this._props[name] = attrValue !== 'false';\n        else this._props[name] = attrValue;\n      } else if (config.default !== undefined) {\n        this._props[name] = config.default;\n      }\n    }\n  }\n\n  static get observedAttributes() {\n    const metadata = this.__forgeMetadata__;\n    return metadata?.props ? Object.keys(metadata.props) : [];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n    const metadata = this.constructor.__forgeMetadata__;\n    const propConfig = metadata?.props?.[name];\n    if (propConfig) {\n      if (newValue === null) this._props[name] = propConfig.default;\n      else if (propConfig.type === Number) this._props[name] = parseFloat(newValue);\n      else if (propConfig.type === Boolean) this._props[name] = newValue !== 'false';\n      else this._props[name] = newValue;\n      this.onUpdate([name]);\n    }\n  }\n\n  connectedCallback() {\n    this.initProps();\n    this._setupEventDelegation();\n    this.update();\n    requestAnimationFrame(() => Promise.resolve(this.onMount()));\n  }\n\n  _setupEventDelegation() {\n    // Set up delegated event listeners on shadow root\n    // Handlers are looked up dynamically by ID, so closures are always fresh\n    const component = this;\n    _delegatedEvents.forEach(eventType => {\n      const useCapture = eventType === 'focus' || eventType === 'blur';\n      this.shadowRoot.addEventListener(eventType, (e) => {\n        // Walk up from target to find element with handler for this event\n        let target = e.target;\n        while (target && target !== component.shadowRoot) {\n          const handlerId = target.getAttribute?.('data-forge-' + eventType);\n          if (handlerId) {\n            const handler = component._handlers.get(parseInt(handlerId));\n            if (handler) {\n              handler.call(component, e);\n            }\n            break;\n          }\n          target = target.parentNode;\n        }\n      }, useCapture);\n    });\n  }\n\n  disconnectedCallback() { this.onUnmount(); }\n  async onMount() {}\n  onUpdate(changedProps) {}\n  onUnmount() {}\n  onFirstRender() {}\n\n  update() {\n    if (!this.shadowRoot) return;\n    // Reset handler registry for fresh closures\n    this._handlers.clear();\n    this._handlerCounter = 0;\n    // Set current component so h() can register handlers\n    _currentComponent = this;\n    const rendered = this.render();\n    _currentComponent = null;\n    if (typeof rendered === 'string') {\n      this.shadowRoot.innerHTML = rendered;\n    } else if (rendered instanceof Node) {\n      // Use DOM morphing to preserve focus and input state\n      if (this.shadowRoot.firstChild) {\n        morph(this.shadowRoot.firstChild, rendered);\n      } else {\n        this.shadowRoot.appendChild(rendered);\n      }    }\n    // Call onFirstRender after first render (refs now available)\n    if (!this._hasRendered) {\n      this._hasRendered = true;\n      // Defer to next frame so browser has completed layout\n      requestAnimationFrame(() => this.onFirstRender());\n    }\n  }\n\n  emit(eventName, detail) {\n    this.dispatchEvent(new CustomEvent(eventName, { detail, bubbles: true, composed: true }));\n  }\n\n  query(selector) { return this.shadowRoot?.querySelector(selector) ?? null; }\n  queryAll(selector) { return Array.from(this.shadowRoot?.querySelectorAll(selector) ?? []); }\n\n  // Asset generation methods\n  async createImage(prompt, options = {}) {\n    const response = await fetch(this._baseUrl + '/api/forge/assets/image', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ prompt, options }),\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Image generation failed');\n    }\n    const result = await response.json();\n    return result.url;\n  }\n\n  async createSpeech(text, options = {}) {\n    const response = await fetch(this._baseUrl + '/api/forge/assets/speech', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text, options }),\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Speech generation failed');\n    }\n    const result = await response.json();\n    return result.url;\n  }\n\n  // AI chat/completion - add intelligence to components\n  async ai(input, options = {}) {\n    // Build messages array from input\n    let messages;\n    if (typeof input === 'string') {\n      // Simple string prompt\n      messages = options.system\n        ? [{ role: 'system', content: options.system }, { role: 'user', content: input }]\n        : [{ role: 'user', content: input }];\n    } else if (Array.isArray(input)) {\n      // Full messages array\n      messages = input;\n    } else {\n      throw new Error('ai() expects a string prompt or messages array');\n    }\n\n    const response = await fetch(this._baseUrl + '/api/forge/ai/chat', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        messages,\n        model: options.model,\n        max_tokens: options.maxTokens || options.max_tokens,\n      }),\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'AI chat failed');\n    }\n    const result = await response.json();\n    return result.response;\n  }\n}\n\nexport function h(tag, attrs, ...children) {\n  const el = document.createElement(tag);\n  let deferredValue = undefined;  // For select elements\n  let refCallback = null;  // For ref callbacks, set value after children\n  if (attrs) {\n    for (const [key, value] of Object.entries(attrs)) {\n      if (key === 'style' && typeof value === 'object') Object.assign(el.style, value);\n      else if (key.startsWith('on') && typeof value === 'function') {\n        // Event delegation: register handler and store ID as data attribute\n        // Handler is looked up dynamically at event time, so closures are always fresh\n        if (_currentComponent) {\n          const eventName = key.slice(2).toLowerCase();\n          const handlerId = ++_currentComponent._handlerCounter;\n          _currentComponent._handlers.set(handlerId, value);\n          el.setAttribute('data-forge-' + eventName, handlerId);\n        }\n      }\n      else if (key === 'className') el.className = String(value);\n      // Handle form element properties that need to be set as properties, not attributes\n      else if (key === 'value' && (tag === 'input' || tag === 'textarea')) {\n        el.value = String(value ?? '');\n      }\n      else if (key === 'value' && tag === 'select') {\n        // Defer setting select value until after options are appended\n        deferredValue = String(value ?? '');\n      }\n      else if (key === 'checked' && tag === 'input') el.checked = Boolean(value);\n      else if (key === 'selected' && tag === 'option') el.selected = Boolean(value);\n      else if (key === 'ref' && typeof value === 'function') { refCallback = value; }\n      else if (typeof value === 'boolean') { if (value) el.setAttribute(key, ''); }\n      else el.setAttribute(key, String(value));\n    }\n  }\n  for (const child of children.flat(Infinity)) {\n    if (child == null || child === false) continue;\n    if (typeof child === 'string' || typeof child === 'number') el.appendChild(document.createTextNode(String(child)));\n    else if (child instanceof Node) el.appendChild(child);\n  }\n  // Set select value after options are appended\n  if (deferredValue !== undefined) {\n    el.value = deferredValue;\n  }\n  // Call ref callback with element\n  if (refCallback) refCallback(el);\n  return el;\n}\n\nexport const Fragment = 'fragment';\n\nexport class ForgeRuntime {\n  constructor(componentId, baseUrl = 'https://forge.entrained.ai') {\n    this.componentId = componentId;\n    this.baseUrl = baseUrl;\n  }\n}\n";
